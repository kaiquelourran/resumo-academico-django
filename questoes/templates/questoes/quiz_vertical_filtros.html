{% extends 'questoes/base.html' %}
{% load static %}

{% block title %}Quiz: {{ assunto.nome }} - Resumo Acad√™mico{% endblock %}

{% block breadcrumb %}
<!-- Breadcrumb Navigation -->
<div class="breadcrumb">
    <div class="header-container">
        <nav class="breadcrumb-nav">
            <a href="{% url 'questoes:index' %}" class="breadcrumb-link">üè† In√≠cio</a>
            <i class="fas fa-chevron-right breadcrumb-separator"></i>
            <a href="{% url 'questoes:escolher_assunto' %}" class="breadcrumb-link">üìö Conte√∫dos</a>
            <i class="fas fa-chevron-right breadcrumb-separator"></i>
            <a href="{% url 'questoes:listar_questoes' assunto.pk %}" class="breadcrumb-link">üìã Lista de Quest√µes</a>
            <i class="fas fa-chevron-right breadcrumb-separator"></i>
            <span class="breadcrumb-current">üéØ Quiz</span>
        </nav>
    </div>
</div>
{% endblock %}

{% block page_header %}
<!-- Page Title Section -->
<div class="page-header">
    <div class="header-container">
        <h1 class="page-title">Quiz: {{ assunto.nome }}</h1>
        <p class="page-subtitle">Sistema de Quest√µes com Filtros Din√¢micos</p>
    </div>
</div>
{% endblock %}

{% block extra_css %}
<style>
    body { background-image: linear-gradient(to top, #00C6FF, #0072FF); min-height: 100vh; margin: 0; }
    .main-container { max-width: 1100px; margin: 0 auto; background: #fff; border-radius: 16px; border: 1px solid transparent; background-image: linear-gradient(#fff,#fff), linear-gradient(to top,#00C6FF,#0072FF); background-origin: border-box; background-clip: padding-box, border-box; box-shadow: 0 20px 40px rgba(0,0,0,.1); padding: 0 20px 24px 20px; }
</style>
{% endblock %}

{% block content %}
<div class="quiz-vertical-container">
    <!-- Progresso + meta -->
    <div class="progress-section">
        <div class="progress-meta">
            <div class="meta-left">
                <span class="meta-title"><i class="fas fa-layer-group"></i> Filtro:</span>
                <span class="meta-chip">
                    {% if filtro_ativo == 'todas' %}Todas{% elif filtro_ativo == 'respondidas' %}Respondidas{% elif filtro_ativo == 'nao-respondidas' %}N√£o Respondidas{% elif filtro_ativo == 'certas' %}Certas{% elif filtro_ativo == 'erradas' %}Erradas{% else %}{{ filtro_ativo|title }}{% endif %}
                </span>
                <span class="meta-sep">‚Ä¢</span>
                <span class="meta-title"><i class="fas fa-hashtag"></i> Total:</span>
                <span class="meta-chip total-questoes">{{ total_questoes }}</span>
            </div>
            <!-- Dropdown de filtro removido a pedido -->
        </div>
        <div class="progress-bar"><div class="progress-fill" style="width:0%"></div></div>
        <p class="progress-text">Progresso</p>
    </div>

    <!-- Lista de quest√µes -->
    <div class="questions-vertical-container" id="questions-container">
        {% for item in questoes_para_renderizar %}
        <div class="question-card" id="questao-{{ item.questao.id }}" data-questao-id="{{ item.questao.id }}" data-status-resposta="{{ item.status }}">
            <div class="question-header">
                <span class="question-number">ID: {{ item.questao.id }}</span>
                <div class="question-header-right">
                    <span class="question-status {{ item.status }}">{{ item.status|capfirst }}</span>
                    <button class="fav-btn" aria-label="Favoritar" title="Favoritar" data-action="toggle-favorito" data-questao-id="{{ item.questao.id }}" onclick="if(window.toggleFavorito){ window.toggleFavorito({{ item.questao.id }}, this); } return false;">‚ù§</button>
                </div>
            </div>
            <div class="question-text">{{ item.questao.texto }}</div>
            <div class="alternatives">
                {% for alternativa in item.alternativas %}
                <div class="alternative-item" id="alternative-{{ alternativa.id }}" role="button" tabindex="0" data-questao-id="{{ item.questao.id }}" data-alternativa-id="{{ alternativa.id }}" data-resposta-correta="{{ alternativa.eh_correta|yesno:'1,0' }}" onclick="responderQuestao({{ item.questao.id }}, {{ alternativa.id }}, this)">
                    <div class="alternative-letter">{{ alternativa.letra }}</div>
                    <div class="alternative-text">{{ alternativa.texto }}</div>
                </div>
                {% endfor %}
            </div>
            <div class="stats-actions">
                <button type="button" class="btn-stats-toggle" data-action="toggle-estatisticas" data-questao-id="{{ item.questao.id }}" onclick="console.log('üéØ Bot√£o Ver Estat√≠sticas clicado! Quest√£o ID:', {{ item.questao.id }}); event.preventDefault(); event.stopPropagation(); if(window.toggleStatsSection){ console.log('‚úÖ toggleStatsSection encontrado, chamando...'); window.toggleStatsSection({{ item.questao.id }}, this); } else { console.error('‚ùå toggleStatsSection n√£o encontrado!'); alert('Erro: Fun√ß√£o n√£o dispon√≠vel. Recarregue a p√°gina.'); } return false;">
                    <i class="fas fa-chart-pie"></i> Ver Estat√≠sticas
                    <i class="fas fa-chevron-down stats-chevron"></i>
                </button>
            </div>
            <!-- Se√ß√£o de Estat√≠sticas Inline (inicialmente oculta) -->
            <div class="stats-section-inline" id="stats-section-{{ item.questao.id }}" style="display:none;">
                <div class="stats-header-inline">
                    <h3>Ver Estat√≠sticas</h3>
                    <button type="button" class="stats-close-inline" onclick="if(window.toggleStatsSection){ window.toggleStatsSection({{ item.questao.id }}); } return false;">
                        <i class="fas fa-chevron-up"></i>
                    </button>
                </div>
                <div class="stats-content-inline">
                    <div class="stats-charts-grid">
                        <!-- Painel Esquerdo: Percentual de Rendimento -->
                        <div class="chart-box-left">
                            <h4 class="chart-title">Percentual de Rendimento</h4>
                            <div class="chart-container">
                                <canvas id="chartAccuracy-{{ item.questao.id }}" height="200"></canvas>
                            </div>
                        </div>
                        
                        <!-- Painel Direito: Alternativas mais respondidas -->
                        <div class="chart-box-right">
                            <h4 class="chart-title">Alternativas mais respondidas</h4>
                            <div class="chart-container">
                                <canvas id="chartAlternatives-{{ item.questao.id }}" height="200"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Painel Inferior: Hist√≥rico de Respostas -->
                    <div class="history-section">
                        <h4 class="history-title">Hist√≥rico de Respostas</h4>
                        <div id="historicoRespostas-{{ item.questao.id }}" class="history-list">
                            <!-- Ser√° preenchido via JavaScript -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
        {% empty %}
        <p>Nenhuma quest√£o encontrada com o filtro atual. Tente mudar o filtro ou o conte√∫do.</p>
        {% endfor %}
    </div>

    <script>
    (function(){
      if (typeof window.responderQuestao === 'function') return;
      window.responderQuestao = function(questaoId, alternativaId, elemento){
        const isTrue = (v)=> (v===true||v===1||v==='1'||v==='true'||v==='True');
        try{
          const card = elemento.closest('.question-card');
          const alternativas = card ? card.querySelectorAll('.alternative-item') : [];
          
          // GARANTIR que o bot√£o de favorito SEMPRE fique clic√°vel (CR√çTICO!)
          const favBtn = card ? card.querySelector('.fav-btn') : null;
          if (favBtn) {
            favBtn.style.pointerEvents = 'auto';
            favBtn.style.cursor = 'pointer';
            favBtn.style.zIndex = '100';
          }
          
          // Limpar TODAS as classes de feedback e desativar cliques APENAS nas alternativas
          alternativas.forEach(alt=>{ 
            alt.classList.remove('alternative-correct','alternative-correct-chosen','alternative-incorrect-chosen'); 
            alt.style.pointerEvents='none'; 
            alt.style.cursor='default'; 
          });
          const dados = (window.questoesList||[]).find(q=>q.questao.id===questaoId);
          const correta = dados ? (dados.alternativas||[]).find(a=>isTrue(a.eh_correta)) : null;
          let corretaId = correta ? Number(correta.id) : NaN;
          
          // Se n√£o encontrou no array, buscar no DOM
          if (isNaN(corretaId) || !corretaId){
            const corretaDom = card.querySelector('.alternative-item[data-resposta-correta="1"]');
            if (corretaDom) corretaId = Number(corretaDom.getAttribute('data-alternativa-id'));
          }
          
          const selId = Number(alternativaId);
          const acertouLocal = !isNaN(corretaId) && (selId === corretaId);
          
          // Aplicar feedback visual INICIAL (ser√° sobrescrito pela resposta do backend)
          alternativas.forEach(alt=>{
            const id=Number(alt.getAttribute('data-alternativa-id'));
            // PRIMEIRO verificar se √© a alternativa clicada e se √© correta
            if(id === selId && acertouLocal){
              alt.classList.add('alternative-correct-chosen'); // Verde com anima√ß√£o
            }
            // Se √© a alternativa CORRETA mas n√£o foi clicada
            else if(id === corretaId && !isNaN(corretaId)){
              alt.classList.add('alternative-correct'); // Verde simples
            }
            // Se foi clicada na ERRADA
            else if(id === selId && !acertouLocal){
              alt.classList.add('alternative-incorrect-chosen'); // Vermelho
            }
          });
          
          const ok = acertouLocal;
          if (card){ card.dataset.statusResposta = ok?'certa':'errada'; const st=card.querySelector('.question-status'); if(st){ st.textContent = ok?'Certa':'Errada'; st.className='question-status '+(ok?'certa':'errada'); } }
          // Toast de feedback removido conforme solicitado
          // if (typeof window.exibirFeedback==='function'){ window.exibirFeedback(ok?'Correto! üòÑ':'Incorreto! üò•', ok); }
          try{ (window.respostas||(window.respostas={}))[questaoId]=selId; }catch(_){ }
          if (typeof window.atualizarProgresso==='function'){ try{ window.atualizarProgresso(); }catch(_){}}
          try{
            const token=document.querySelector('[name=csrfmiddlewaretoken]').value;
            console.log('üöÄ Enviando resposta (template inline):', {questaoId, selId});
            fetch('/questoes/quiz/validar/',{method:'POST', headers:{'Content-Type':'application/json','X-CSRFToken':token}, body:JSON.stringify({id_questao:questaoId,id_alternativa:selId})})
              .then(r=>r.ok?r.json():Promise.reject(new Error('HTTP '+r.status)))
              .then(data=>{
                console.log('‚úÖ Resposta backend (template inline):', data);
                // Usar resposta do backend como autoritativa
                const corretaBackend = Number(data.id_alternativa_correta);
                const acertouBackend = !!data.acertou;
                const selecionadaBackend = Number(data.id_alternativa_selecionada);
                
                // Limpar TODAS as classes
                alternativas.forEach(alt=>{
                  alt.classList.remove('alternative-correct','alternative-correct-chosen','alternative-incorrect-chosen');
                });
                
                // Aplicar feedback baseado na resposta do backend
                alternativas.forEach(alt=>{
                  const id=Number(alt.getAttribute('data-alternativa-id'));
                  if (id === corretaBackend) {
                    if (id === selecionadaBackend && acertouBackend) {
                      alt.classList.add('alternative-correct-chosen'); // Verde com anima√ß√£o
                    } else {
                      alt.classList.add('alternative-correct'); // Verde simples
                    }
                  } else if (id === selecionadaBackend && !acertouBackend) {
                    alt.classList.add('alternative-incorrect-chosen'); // Vermelho
                  }
                });
                
                // Atualizar status do card
                if (card){ 
                  card.dataset.statusResposta = acertouBackend?'certa':'errada'; 
                  const st=card.querySelector('.question-status'); 
                  if(st){ 
                    st.textContent = acertouBackend?'Certa':'Errada'; 
                    st.className='question-status '+(acertouBackend?'certa':'errada'); 
                  } 
                }
                
                // Toast de feedback removido conforme solicitado
                // if (typeof window.exibirFeedback==='function'){ 
                //   window.exibirFeedback(acertouBackend?'Correto! üòÑ':'Incorreto! üò•', acertouBackend); 
                // }
              })
              .catch(e=>console.error('‚ùå Erro:', e));
          }catch(_){ }
        }catch(err){ console.warn('Falha ao responder:', err); }
      };
    })();
    </script>
    
    <!-- Script ser√° executado depois que toggleFavorito for definido -->

    <!-- Navega√ß√£o -->
    <div class="navigation">
        <button class="btn-nav btn-anterior" id="btn-anterior" onclick="questaoAnterior()" disabled><i class="fas fa-arrow-left"></i> Anterior</button>
        <button class="btn-nav btn-proximo" id="btn-proximo" onclick="proximaQuestao()">Pr√≥ximo <i class="fas fa-arrow-right"></i></button>
    </div>

    <div class="back-controls">
        <a href="{% url 'questoes:listar_questoes' assunto.pk %}" class="btn-voltar"><i class="fas fa-list"></i> Voltar √† Lista</a>
    </div>
</div>

{{ questoes_json_seguro|json_script:"questoes-data" }}
<script>
    // ===== DEFINIR toggleFavorito PRIMEIRO (antes de qualquer outro c√≥digo) =====
    (function(){
      // Favoritos via localStorage - FUN√á√ïES AUXILIARES
      function getFavKey(){ return 'rq_favoritos'; }
      function getFavoritos(){ try{ return new Set(JSON.parse(localStorage.getItem(getFavKey())||'[]')); }catch(e){ return new Set(); } }
      function saveFavoritos(set){ localStorage.setItem(getFavKey(), JSON.stringify(Array.from(set))); }
      
      // FUN√á√ÉO PRINCIPAL toggleFavorito - DEFINIR ANTES DE QUALQUER COISA
      window.toggleFavorito = function(id, btn){
        try {
          const favs = getFavoritos();
          id = Number(id);
          const eraFavorito = favs.has(id);
          
          console.log('üîÑ toggleFavorito chamado! ID:', id, 'Era favorito:', eraFavorito);
          
          if(eraFavorito){
            favs.delete(id);
            console.log('‚ùå Removendo favorito ID:', id);
          } else {
            favs.add(id);
            console.log('‚úÖ Adicionando favorito ID:', id);
          }
          
          // Salvar no localStorage IMEDIATAMENTE
          saveFavoritos(favs);
          console.log('üíæ Favoritos salvos no localStorage:', Array.from(favs));
          
          // Atualizar visual do bot√£o clicado PRIMEIRO
          if(btn){
            if(favs.has(id)){
              btn.classList.add('is-fav');
              // FOR√áAR estilos inline para garantir visual
              btn.style.background = '#ff3860';
              btn.style.borderColor = '#ff3860';
              btn.style.color = '#fff';
              console.log('‚úÖ Bot√£o marcado como favorito (visual)');
            } else {
              btn.classList.remove('is-fav');
              // Remover estilos inline quando desfavoritar
              btn.style.background = '';
              btn.style.borderColor = '';
              btn.style.color = '';
              console.log('‚ùå Bot√£o desmarcado como favorito (visual)');
            }
          }
          
          // Marcar no card para poss√≠veis filtros futuros
          const card = btn ? btn.closest('.question-card') : document.querySelector(`.question-card[data-questao-id='${id}']`);
          if(card){
            if(favs.has(id)) {
              card.setAttribute('data-favorito','1');
              console.log('‚úÖ Card marcado como favorito');
            } else {
              card.removeAttribute('data-favorito');
              console.log('‚ùå Card desmarcado como favorito');
            }
          }
          
          // Atualizar TODOS os bot√µes de favorito na p√°gina (caso haja duplicatas)
          // IMPORTANTE: Fazer isso DEPOIS de salvar para garantir que usa o estado correto
          setTimeout(() => {
            if (window.aplicarFavoritosNosCards) {
              try {
                window.aplicarFavoritosNosCards();
                console.log('‚úÖ Todos os bot√µes de favorito atualizados');
              } catch (err) {
                console.error('Erro ao aplicar favoritos em todos os cards:', err);
              }
            }
          }, 50);
          
          // Verificar se realmente foi salvo
          const verificacao = getFavoritos();
          const agoraEFavorito = verificacao.has(id);
          console.log('üîç Verifica√ß√£o - Favoritos no localStorage ap√≥s salvar:', Array.from(verificacao));
          console.log('‚úÖ toggleFavorito executado! ID:', id, 'Era favorito:', eraFavorito, 'Agora √© favorito:', agoraEFavorito);
          
          return agoraEFavorito;
        } catch (err) {
          console.error('‚ùå Erro em toggleFavorito:', err);
          alert('Erro ao favoritar/desfavoritar quest√£o. Por favor, tente novamente.');
          return false;
        }
      };
      
      // Expor fun√ß√µes auxiliares tamb√©m
      window.getFavoritos = getFavoritos;
      window.saveFavoritos = saveFavoritos;
      window.isFavorito = function(id){ return getFavoritos().has(Number(id)); };
      
      console.log('‚úÖ toggleFavorito definido no escopo global!');
      
      // ===== FUN√á√ÉO PARA TOGGLE DA SE√á√ÉO DE ESTAT√çSTICAS INLINE =====
      window.toggleStatsSection = function(idQuestao, btnElement) {
        try {
          console.log('üîÑ toggleStatsSection chamado! ID Quest√£o:', idQuestao, 'btnElement:', btnElement);
          
          // Garantir que idQuestao seja um n√∫mero
          idQuestao = Number(idQuestao);
          if (!idQuestao || isNaN(idQuestao)) {
            console.error('‚ùå ID de quest√£o inv√°lido:', idQuestao);
            return false;
          }
          
          const sectionId = `stats-section-${idQuestao}`;
          console.log('üîç Procurando se√ß√£o:', sectionId);
          const section = document.getElementById(sectionId);
          
          if (!section) {
            console.error('‚ùå Se√ß√£o de estat√≠sticas n√£o encontrada:', sectionId);
            console.log('üîç Todas as se√ß√µes dispon√≠veis:', Array.from(document.querySelectorAll('[id^="stats-section-"]')).map(el => el.id));
            return false;
          }
          
          console.log('‚úÖ Se√ß√£o encontrada!');
          const isExpanded = section.style.display !== 'none' && section.style.display !== '';
          console.log('üìä Se√ß√£o est√° expandida?', isExpanded);
          
          if (isExpanded) {
            // Colapsar
            section.style.display = 'none';
            section.setAttribute('aria-expanded', 'false');
            
            // Atualizar √≠cone do bot√£o
            if (btnElement) {
              const chevron = btnElement.querySelector('.stats-chevron');
              if (chevron) {
                chevron.classList.remove('fa-chevron-up');
                chevron.classList.add('fa-chevron-down');
              }
            }
            
            console.log('‚úÖ Se√ß√£o de estat√≠sticas colapsada para quest√£o', idQuestao);
          } else {
            // Expandir
            section.style.display = 'block';
            section.setAttribute('aria-expanded', 'true');
            
            // Atualizar √≠cone do bot√£o
            if (btnElement) {
              const chevron = btnElement.querySelector('.stats-chevron');
              if (chevron) {
                chevron.classList.remove('fa-chevron-down');
                chevron.classList.add('fa-chevron-up');
              }
            }
            
            // SEMPRE carregar estat√≠sticas ao expandir (garantir que dados estejam atualizados)
            console.log('üîÑ Carregando estat√≠sticas para quest√£o', idQuestao);
            if (window.fetchAndRenderStatsInline) {
              window.fetchAndRenderStatsInline(idQuestao, 'user', 14);
            } else {
              console.error('‚ùå fetchAndRenderStatsInline n√£o est√° dispon√≠vel!');
            }
            
            console.log('‚úÖ Se√ß√£o de estat√≠sticas expandida para quest√£o', idQuestao);
          }
          
          return false;
        } catch (error) {
          console.error('‚ùå Erro ao toggle se√ß√£o de estat√≠sticas:', error);
          return false;
        }
      };
      
      console.log('‚úÖ toggleStatsSection definido no escopo global!');
      
      // Aplicar favoritos IMEDIATAMENTE nos cards j√° renderizados pelo servidor
      (function aplicarFavoritosImediato(){
        try {
          const favs = getFavoritos();
          const favsArray = Array.from(favs);
          console.log('üöÄ Aplicando favoritos IMEDIATAMENTE... Total:', favsArray.length, 'IDs:', favsArray);
          
          const buttons = document.querySelectorAll('.fav-btn');
          console.log('üîç Bot√µes encontrados (imediato):', buttons.length);
          
          buttons.forEach((btn)=>{
            const id = Number(btn.getAttribute('data-questao-id'));
            if (id && favs.has(id)) {
              btn.classList.add('is-fav');
              btn.style.background = '#ff3860';
              btn.style.borderColor = '#ff3860';
              btn.style.color = '#fff';
              console.log('‚úÖ Favorito aplicado IMEDIATAMENTE ao bot√£o ID', id);
            }
          });
        } catch(e) {
          console.error('‚ùå Erro ao aplicar favoritos imediatamente:', e);
        }
      })();
    })();
    
    // Ler dados de forma segura do <script type="application/json">
    const dataElement = document.getElementById('questoes-data');
    const questoesData = dataElement ? JSON.parse(dataElement.textContent) : [];
    const assuntoId = {{ assunto.pk }};
    const filtroAtivo = '{{ filtro_ativo|escapejs }}';
    const questaoInicial = {{ questao_inicial }};
    const userAuthenticated = {{ user_authenticated|yesno:"true,false" }};
    const csrfToken = '{{ csrf_token|escapejs }}';
    
</script>

{% csrf_token %}

<style>
/* ===== Layout ===== */
.quiz-vertical-container { max-width: 960px; margin: 0 auto; padding: 16px 4px 0 4px; }
.progress-section { background: #f8fafc; padding: 14px 16px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,.06); margin: 16px 0 20px 0; }
.progress-meta { display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; margin-bottom:10px; }
.meta-left { display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
.meta-title { color:#475569; font-weight:700; font-size:.95rem; }
.meta-chip { padding:4px 10px; border-radius:999px; background:#eef2ff; color:#1e3a8a; font-weight:700; font-size:.9rem; }
.meta-sep { color:#94a3b8; }
.progress-bar { width:100%; height:8px; background:#e9ecef; border-radius:999px; overflow:hidden; }
.progress-fill { height:100%; background:linear-gradient(90deg,#00C6FF,#0072FF); transition:width .3s ease; }
.progress-text { margin:8px 0 0 0; text-align:center; font-weight:700; color:#475569; }

/* ===== Card de quest√£o ===== */
.question-card { background:#fff; border:1px solid #e2e8f0; border-radius:14px; box-shadow:0 6px 18px rgba(2,6,23,.06); overflow:hidden; transition:transform .2s ease, box-shadow .2s ease; }
.question-card:not(:first-child) { margin-top:16px; }
.question-card:hover { transform:translateY(-3px); box-shadow:0 10px 26px rgba(2,6,23,.1); }
.question-header { display:flex; justify-content:space-between; align-items:center; gap:12px; padding:12px 14px; background:linear-gradient(135deg,#00C6FF 0%,#0072FF 100%); color:#fff; }
.question-number { font-weight:800; letter-spacing:.2px; font-size:1rem; }
.question-status { background:rgba(255,255,255,.18); padding:6px 10px; border-radius:999px; font-weight:800; font-size:.8rem; }
.question-status.certa{ background:linear-gradient(135deg,#1db954,#17b77a); color:#ffffff; box-shadow:0 2px 10px rgba(23,183,122,.25); border:1px solid rgba(23,183,122,.35); }
.question-status.errada{ background:linear-gradient(135deg,#e63946,#ff6b6b); color:#ffffff; box-shadow:0 2px 10px rgba(230,57,70,.25); border:1px solid rgba(230,57,70,.35); }
.question-status.nao-respondida{ background:linear-gradient(135deg,#ffd166,#fdbb2d); color:#7a4b00; box-shadow:0 2px 10px rgba(253,187,45,.25); border:1px solid rgba(253,187,45,.4); }
.question-status.respondida{ background:linear-gradient(135deg,#4dabf7,#228be6); color:#ffffff; box-shadow:0 2px 10px rgba(34,139,230,.25); border:1px solid rgba(34,139,230,.35); }
.question-text { padding:16px 14px; font-size:1rem; line-height:1.6; color:#0f172a; }

/* ===== Alternativas ===== */
.alternatives { padding: 0 14px 14px 14px; display:flex; flex-direction:column; gap:10px; user-select:none; }
.alternative-item { display:flex; align-items:flex-start; gap:12px; border:1.5px solid #e2e8f0; border-radius:12px; padding:12px 14px; background:#fff; cursor:pointer; pointer-events:auto; transition:border-color .2s ease, background .2s ease, transform .2s ease; }
.alternative-item:hover { border-color:#cfe2ff; background:#f8fbff; transform:translateX(3px); }
.alternative-item:focus { outline:3px solid rgba(0,114,255,.2); }
.alternative-letter { width:32px; height:32px; border-radius:999px; display:flex; align-items:center; justify-content:center; font-weight:800; color:#fff; background:linear-gradient(135deg,#0072FF 0%,#00C6FF 100%); box-shadow:0 2px 8px rgba(0,114,255,.2); flex-shrink:0; }
.alternative-text { color:#111827; font-weight:600; }
.alternative-item.resposta-correta { background:linear-gradient(135deg,#28a745 0%, #20c997 100%) !important; border-color:#28a745 !important; color:#fff !important; }
.alternative-item.incorreta { background:linear-gradient(135deg,#dc3545 0%, #e74c3c 100%) !important; border-color:#dc3545 !important; color:#fff !important; }

/* Navega√ß√£o */
.navigation { display:flex; gap:12px; margin:18px 0; }
.btn-nav { flex:1; padding:12px 16px; border:none; border-radius:10px; font-weight:800; color:#fff; cursor:pointer; display:flex; align-items:center; justify-content:center; gap:8px; transition:transform .2s ease, box-shadow .2s ease; }
.btn-anterior { background:#64748b; }
.btn-proximo { background:#22c55e; }
.btn-nav:hover { transform:translateY(-2px); box-shadow:0 10px 22px rgba(2,6,23,.12); }

.back-controls { text-align:center; }
.btn-voltar { display:inline-flex; align-items:center; gap:8px; padding:10px 14px; border-radius:10px; background:#6c757d; color:#fff; text-decoration:none; font-weight:800; }
.btn-voltar:hover { background:#5a6268; }

.sr-only { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }
.fav-btn{ 
  margin-left:8px; 
  background:#ffffff22 !important; 
  border:1px solid rgba(255,255,255,.4) !important; 
  color:#fff !important; 
  font-weight:900; 
  border-radius:999px; 
  width:34px; 
  height:28px; 
  display:inline-flex !important; 
  align-items:center; 
  justify-content:center; 
  cursor:pointer !important; 
  transition:transform .2s ease, background .2s ease; 
  position:relative !important; 
  z-index:99999 !important; 
  pointer-events:auto !important; 
  user-select:none;
}
.fav-btn:hover{ transform:translateY(-1px); background:#ffffff33; }
.fav-btn.is-fav{ background:#ff3860 !important; border-color:#ff3860 !important; color:#fff !important; box-shadow:0 0 0 3px rgba(255,56,96,.25); }
.question-header-right{ 
  display:flex !important; 
  flex-direction:column; 
  align-items:flex-end; 
  gap:6px; 
  position:relative !important; 
  z-index:100 !important; 
  pointer-events:auto !important;
}
.question-header-right .fav-btn{ 
  margin-left:0; 
  background:#ffffff22 !important; 
  border:1px solid rgba(255,255,255,.4) !important; 
  color:#fff !important; 
  font-weight:900; 
  border-radius:999px; 
  width:34px; 
  height:28px; 
  display:inline-flex !important; 
  align-items:center; 
  justify-content:center; 
  cursor:pointer !important; 
  transition:transform .2s ease, background .2s ease; 
  position:relative !important; 
  z-index:99999 !important; 
  pointer-events:auto !important;
  user-select:none;
}
.question-header-right .fav-btn:hover{ transform:translateY(-1px); background:#ffffff33; }
.question-header-right .fav-btn.is-fav{ background:#ff3860 !important; border-color:#ff3860 !important; color:#fff !important; box-shadow:0 0 0 3px rgba(255,56,96,.25); }
/* remove posicionamento absoluto para evitar sobreposi√ß√£o */
.question-header-right .question-status{ position:relative; right:auto; top:auto; z-index:5; }
/* Garantir que question-header::before n√£o bloqueie cliques */
.question-header::before{ pointer-events:none !important; }
.question-header{ pointer-events:auto !important; }

/* Bot√£o Ver Estat√≠sticas no card (Toggle) */
.btn-stats-toggle {
  display: inline-flex !important;
  align-items: center;
  gap: 8px;
  padding: 10px 16px;
  border-radius: 10px;
  background: linear-gradient(135deg, #00C6FF 0%, #0072FF 100%) !important;
  color: #fff !important;
  text-decoration: none;
  font-weight: 700;
  border: 1px solid rgba(0, 114, 255, 0.6);
  box-shadow: 0 6px 16px rgba(0, 114, 255, 0.18);
  cursor: pointer !important;
  pointer-events: auto !important;
  position: relative !important;
  z-index: 10 !important;
  transition: all 0.2s ease;
  width: 100%;
  justify-content: center;
  margin-top: 12px;
}

.btn-stats-toggle:hover {
  filter: brightness(1.05);
  transform: translateY(-1px);
  box-shadow: 0 8px 20px rgba(0, 114, 255, 0.25);
}

.stats-chevron {
  margin-left: auto;
  transition: transform 0.3s ease;
}

/* Se√ß√£o de Estat√≠sticas Inline */
.stats-section-inline {
  margin-top: 16px;
  padding: 20px;
  background: #f8fafc;
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  animation: slideDown 0.3s ease-out;
}

@keyframes slideDown {
  from {
    opacity: 0;
    max-height: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    max-height: 2000px;
    transform: translateY(0);
  }
}

.stats-header-inline {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding-bottom: 12px;
  border-bottom: 2px solid #e5e7eb;
}

.stats-header-inline h3 {
  margin: 0;
  font-size: 1.2rem;
  font-weight: 700;
  color: #0f172a;
}

.stats-close-inline {
  background: transparent;
  border: none;
  color: #64748b;
  cursor: pointer;
  font-size: 1.2rem;
  padding: 8px;
  border-radius: 50%;
  transition: all 0.2s;
}

.stats-close-inline:hover {
  background: #e5e7eb;
  color: #0f172a;
}

.stats-content-inline {
  /* Conte√∫do j√° est√° estilizado com as classes existentes */
}

/* Bot√£o Ver Estat√≠sticas no card (antigo - manter para compatibilidade) */
.stats-actions{ margin-top:12px; position:relative; z-index:10; }
.btn-stats{ 
  display:inline-flex !important; 
  align-items:center; 
  gap:8px; 
  padding:8px 14px; 
  border-radius:10px; 
  background:linear-gradient(135deg,#00C6FF 0%, #0072FF 100%) !important; 
  color:#fff !important; 
  text-decoration:none; 
  font-weight:800; 
  border:1px solid rgba(0,114,255,.6); 
  box-shadow:0 6px 16px rgba(0,114,255,.18); 
  cursor:pointer !important;
  pointer-events:auto !important;
  position:relative !important;
  z-index:9999 !important;
  user-select:none;
}
.btn-stats:hover{ filter:brightness(1.05); }
</style>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

<script>
let questoesList = []; let respostas = {};
let currentCardIndex = 0;

// Navega√ß√£o b√°sica entre cards (scroll suave)
function questaoAnterior(){
  try{
    const cards = Array.from(document.querySelectorAll('.question-card'));
    if (!cards.length) return;
    currentCardIndex = Math.max(0, currentCardIndex - 1);
    const target = cards[currentCardIndex];
    if (target) target.scrollIntoView({ behavior:'smooth', block:'start' });
  }catch(e){ console.warn('questaoAnterior falhou:', e); }
}
function proximaQuestao(){
  try{
    const cards = Array.from(document.querySelectorAll('.question-card'));
    if (!cards.length) return;
    currentCardIndex = Math.min(cards.length - 1, currentCardIndex + 1);
    const target = cards[currentCardIndex];
    if (target) target.scrollIntoView({ behavior:'smooth', block:'start' });
  }catch(e){ console.warn('proximaQuestao falhou:', e); }
}

// Atualiza √≠ndice atual baseado no primeiro card vis√≠vel
function atualizarIndiceAtual(){
  const cards = Array.from(document.querySelectorAll('.question-card'));
  const top = window.scrollY || document.documentElement.scrollTop || 0;
  let idx = 0;
  for (let i=0;i<cards.length;i++){
    if (cards[i].getBoundingClientRect().top + top >= top - 4){ idx = i; break; }
  }
  currentCardIndex = idx;
}
window.addEventListener('scroll', ()=>{ try{ atualizarIndiceAtual(); }catch(_){} }, { passive:true });

// Este script ser√° executado DEPOIS que aplicarFavoritosNosCards estiver definido

document.addEventListener('DOMContentLoaded', function(){
  try {
    questoesList = (Array.isArray(questoesData)) ? questoesData : [];
  } catch (e) {
    console.error('Falha ao obter questoes JSON:', e);
    questoesList = [];
  }
  if(!questoesList || !questoesList.length){ 
    // Mesmo sem quest√µes din√¢micas, aplicar favoritos nos cards do servidor
    setTimeout(function(){
      if (window.aplicarFavoritosNosCards) {
        console.log('üîÑ Aplicando favoritos em cards do servidor (sem quest√µes din√¢micas)...');
        window.aplicarFavoritosNosCards();
      }
    }, 200);
    mostrarMensagemVazia(); 
    return; 
  }
  renderizarTodasQuestoes(); 
  
  // APLICAR FAVORITOS IMEDIATAMENTE ap√≥s renderizar
  aplicarFavoritosNosCards();
  
  atualizarProgresso(); 
  inicializarFiltros();
  // Garante delega√ß√£o mesmo em renderiza√ß√£o inicial server-side
  // IMPORTANTE: Ordem de binding - estat√≠sticas primeiro (useCapture), depois alternativas e favoritos
  try { bindStatsButtons(); } catch(e) { console.error('Erro ao bindStatsButtons:', e); }
  try { bindAlternativas(); } catch(e) { console.error('Erro ao bindAlternativas:', e); }
  try { bindFavoritos(); } catch(e) { console.error('Erro ao bindFavoritos:', e); }
  currentCardIndex = 0;
  
  // Aplicar favoritos novamente ap√≥s delays para garantir
  setTimeout(function(){
    aplicarFavoritosNosCards();
  }, 50);
  
  setTimeout(function(){
    aplicarFavoritosNosCards();
  }, 200);
  
  setTimeout(function(){
    aplicarFavoritosNosCards();
  }, 500);
});

function renderizarTodasQuestoes(){ 
  const c=document.getElementById('questions-container'); 
  if (!c) return;
  
  // Se j√° houver cards do servidor, aplicar favoritos ANTES de limpar
  if (c.children.length > 0 && window.aplicarFavoritosNosCards) {
    console.log('üîÑ Aplicando favoritos em cards do servidor ANTES de limpar...');
    window.aplicarFavoritosNosCards();
  }
  
  c.innerHTML=''; 
  questoesList.forEach((q,i)=>c.appendChild(criarCardQuestao(q,i))); 
  // Aplicar favoritos imediatamente ap√≥s renderizar
  setTimeout(function(){
    aplicarFavoritosNosCards();
  }, 10);
}

function criarCardQuestao(questaoData,index){
  const card=document.createElement('div'); card.className='question-card';
  card.id = `questao-${questaoData.questao.id}`;
  card.dataset.questaoId=questaoData.questao.id; card.dataset.questaoIndex=index; card.dataset.statusResposta=questaoData.status;
  card.innerHTML=`
    <div class="question-header">\n      <span class="question-number">Quest√£o ${index+1} de ${questoesList.length} (ID: ${questaoData.questao.id})</span>\n      <div class="question-header-right">\n        <span class="question-status ${questaoData.status}">${formatarStatus(questaoData.status)}</span>\n        <button class="fav-btn" aria-label="Favoritar" title="Favoritar" data-action="toggle-favorito" data-questao-id="${questaoData.questao.id}" onclick="if(window.toggleFavorito){ window.toggleFavorito(${questaoData.questao.id}, this); } return false;">‚ù§</button>\n      </div>\n    </div>\n    <div class="question-text">${questaoData.questao.texto}</div>\n    <div class="alternatives">\n      ${questaoData.alternativas.map(alt=>`\n        <div class=\"alternative-item\" id=\"alternative-${alt.id}\" role=\"button\" tabindex=\"0\" data-questao-id=\"${questaoData.questao.id}\" data-alternativa-id=\"${alt.id}\" data-resposta-correta=\"${(alt.eh_correta===true||alt.eh_correta===1||alt.eh_correta==='1'||alt.eh_correta==='true'||alt.eh_correta==='True')?'1':'0'}\" onclick="if(window.responderQuestao){ window.responderQuestao(${questaoData.questao.id}, ${alt.id}, this); } return false;">\n          <div class=\"alternative-letter\">${alt.letra}</div>\n          <div class=\"alternative-text\">${alt.texto}</div>\n        </div>`).join('')}\n    </div>\n    <div class="stats-actions">\n      <button type="button" class="btn-stats-toggle" data-action="toggle-estatisticas" data-questao-id="${questaoData.questao.id}" onclick="console.log('üéØ Bot√£o Ver Estat√≠sticas clicado (din√¢mico)! Quest√£o ID:', ${questaoData.questao.id}); event.preventDefault(); event.stopPropagation(); if(window.toggleStatsSection){ console.log('‚úÖ toggleStatsSection encontrado, chamando...'); window.toggleStatsSection(${questaoData.questao.id}, this); } else { console.error('‚ùå toggleStatsSection n√£o encontrado!'); alert('Erro: Fun√ß√£o n√£o dispon√≠vel. Recarregue a p√°gina.'); } return false;">\n        <i class="fas fa-chart-pie"></i> Ver Estat√≠sticas\n        <i class="fas fa-chevron-down stats-chevron"></i>\n      </button>\n    </div>\n    <!-- Se√ß√£o de Estat√≠sticas Inline (inicialmente oculta) -->\n    <div class="stats-section-inline" id="stats-section-${questaoData.questao.id}" style="display:none;">\n      <div class="stats-header-inline">\n        <h3>Ver Estat√≠sticas</h3>\n        <button type="button" class="stats-close-inline" onclick="if(window.toggleStatsSection){ window.toggleStatsSection(${questaoData.questao.id}); } return false;">\n          <i class="fas fa-chevron-up"></i>\n        </button>\n      </div>\n      <div class="stats-content-inline">\n        <div class="stats-charts-grid">\n          <div class="chart-box-left">\n            <h4 class="chart-title">Percentual de Rendimento</h4>\n            <div class="chart-container">\n              <canvas id="chartAccuracy-${questaoData.questao.id}" height="200"></canvas>\n            </div>\n          </div>\n          <div class="chart-box-right">\n            <h4 class="chart-title">Alternativas mais respondidas</h4>\n            <div class="chart-container">\n              <canvas id="chartAlternatives-${questaoData.questao.id}" height="200"></canvas>\n            </div>\n          </div>\n        </div>\n        <div class="history-section">\n          <h4 class="history-title">Hist√≥rico de Respostas</h4>\n          <div id="historicoRespostas-${questaoData.questao.id}" class="history-list"></div>\n        </div>\n      </div>\n    </div>`; 
  // Garantir que os bot√µes tenham pointer-events ativo e aplicar estado de favorito
  setTimeout(function(){
    const favBtn = card.querySelector('.fav-btn');
    if (favBtn) {
      favBtn.style.pointerEvents = 'auto';
      favBtn.style.cursor = 'pointer';
      favBtn.style.zIndex = '99999';
      
      // Aplicar estado de favorito imediatamente para este card
      if (window.getFavoritos) {
        const favs = window.getFavoritos();
        const questaoId = Number(favBtn.getAttribute('data-questao-id') || favBtn.dataset.questaoId);
        if (questaoId && favs.has(questaoId)) {
          favBtn.classList.add('is-fav');
          card.setAttribute('data-favorito','1');
        }
      }
    }
    
    // Garantir que o bot√£o de estat√≠sticas seja clic√°vel
    const statsBtn = card.querySelector('.btn-stats');
    if (statsBtn) {
      statsBtn.style.pointerEvents = 'auto';
      statsBtn.style.cursor = 'pointer';
      statsBtn.style.zIndex = '9999';
      statsBtn.style.position = 'relative';
      
      // Adicionar onclick inline como fallback (se ainda n√£o tiver)
      const questaoId = statsBtn.getAttribute('data-questao-id');
      if (questaoId) {
        // Sempre garantir que o onclick funcione, mesmo que j√° tenha um
        const existingOnclick = statsBtn.getAttribute('onclick');
        if (!existingOnclick || !existingOnclick.includes('toggleStatsSection')) {
          statsBtn.onclick = function(e){
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            console.log('üéØ Bot√£o de estat√≠sticas clicado via JavaScript onclick! ID:', questaoId);
            if (window.toggleStatsSection) {
              console.log('‚úÖ Chamando toggleStatsSection...');
              window.toggleStatsSection(Number(questaoId), statsBtn);
            } else {
              console.error('‚ùå window.toggleStatsSection n√£o encontrado!');
            }
            return false;
          };
          console.log('‚úÖ onclick JavaScript adicionado ao bot√£o de estat√≠sticas ID:', questaoId);
        }
      }
    }
    
    // GARANTIR que as alternativas sejam clic√°veis (CR√çTICO!)
    const altItems = card.querySelectorAll('.alternative-item');
    altItems.forEach(altItem => {
      altItem.style.pointerEvents = 'auto';
      altItem.style.cursor = 'pointer';
      
      // Adicionar onclick inline se n√£o tiver
      if (!altItem.getAttribute('onclick')) {
        const questaoId = altItem.getAttribute('data-questao-id');
        const alternativaId = altItem.getAttribute('data-alternativa-id');
        if (questaoId && alternativaId) {
          altItem.onclick = function(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('üéØ Alternativa clicada via JavaScript onclick! Quest√£o:', questaoId, 'Alternativa:', alternativaId);
            if (window.responderQuestao) {
              window.responderQuestao(Number(questaoId), Number(alternativaId), this);
            } else {
              console.error('‚ùå window.responderQuestao n√£o encontrado!');
            }
            return false;
          };
        }
      }
    });
  }, 0);
  return card; }

function formatarStatus(s){ const m={'nao-respondida':'N√£o Respondida','respondida':'Respondida','certa':'Certa','errada':'Errada'}; return m[s]||s; }

function responderQuestao(questaoId,alternativaId,elemento){
  try {
    const isTrue = (v)=> (v===true||v===1||v==='1'||v==='true'||v==='True');
    const card=elemento.closest('.question-card'); 
    if (!card) {
      console.error('Erro: card n√£o encontrado para quest√£o', questaoId);
      return;
    }
    const alternativas=card.querySelectorAll('.alternative-item');
    try { console.log('[responderQuestao] qid=', questaoId, 'aid=', alternativaId); } catch(_) {}
  
  // GARANTIR que o bot√£o de favorito SEMPRE fique clic√°vel (CR√çTICO!)
  const favBtn = card ? card.querySelector('.fav-btn') : null;
  if (favBtn) {
    favBtn.style.pointerEvents = 'auto';
    favBtn.style.cursor = 'pointer';
    favBtn.style.zIndex = '100';
  }
  
  // Limpar TODAS as classes de feedback ANTES de responder
  // IMPORTANTE: N√ÉO desativar pointer-events aqui! As alternativas devem ser clic√°veis ANTES de responder
  alternativas.forEach(alt=>{ 
    alt.classList.remove('alternative-correct','alternative-correct-chosen','alternative-incorrect-chosen'); 
    // N√ÉO desativar pointer-events aqui - as alternativas devem ser clic√°veis para poder responder
    // alt.style.pointerEvents='auto'; // Garantir que esteja ativo
    // alt.style.cursor='pointer'; // Garantir cursor de pointer
  });
  
  // AP√ìS processar a resposta, ent√£o desativar para evitar cliques duplicados
  // Isso ser√° feito ap√≥s a valida√ß√£o do backend
  const dados=(window.questoesList||[]).find(q=>q.questao.id===questaoId);
  let corretaId = NaN;
  if (dados && Array.isArray(dados.alternativas)){
    const c = dados.alternativas.find(a=>isTrue(a.eh_correta));
    if (c) corretaId = Number(c.id);
  }
  if (isNaN(corretaId)){
    const corretaDom = card.querySelector('.alternative-item[data-resposta-correta="1"]');
    if (corretaDom) corretaId = Number(corretaDom.getAttribute('data-alternativa-id'));
  }
  const selId=Number(alternativaId);
  try { console.log('[responderQuestao] corretaId=', corretaId, 'selId=', selId); } catch(_) {}
  // registra resposta p/ progresso
  respostas[questaoId] = selId;
  
  // Feedback visual INICIAL (ser√° sobrescrito pela resposta do backend)
  // Limpar classes anteriores
  alternativas.forEach(alt=>{
    alt.classList.remove('alternative-correct','alternative-correct-chosen','alternative-incorrect-chosen');
  });
  
  // Aplicar feedback baseado em l√≥gica local (tempor√°rio at√© receber do backend)
  const acertouLocal = (selId === corretaId);
  alternativas.forEach(alt=>{ 
    const id=Number(alt.dataset.alternativaId);
    if(id === corretaId){
      if(id === selId && acertouLocal){
        alt.classList.add('alternative-correct-chosen'); // Verde com anima√ß√£o se clicou na certa
      } else {
        alt.classList.add('alternative-correct'); // Verde simples para a alternativa correta
      }
    } else if(id === selId && !acertouLocal){
      alt.classList.add('alternative-incorrect-chosen'); // Vermelho se clicou na errada
    }
  });
    const idx=questoesList.findIndex(q=>q.questao.id===questaoId); if(idx>-1){ const ok=selId===corretaId; questoesList[idx].status=ok?'certa':'errada'; card.dataset.statusResposta=ok?'certa':'errada'; const st=card.querySelector('.question-status'); if(st){ st.textContent=ok?'Certa':'Errada'; st.className=`question-status ${ok?'certa':'errada'}`; } }
    // Toast de feedback removido conforme solicitado
    // try { if (typeof exibirFeedback==='function') exibirFeedback((selId===corretaId)?'Correto! üòÑ':'Incorreto! üò•', (selId===corretaId)); } catch(_) {}
    atualizarProgresso();
    const tokenEl = document.querySelector('[name=csrfmiddlewaretoken]');
    if (!tokenEl) {
      console.error('Erro: CSRF token n√£o encontrado');
      return;
    }
    const token = tokenEl.value;
    fetch('/questoes/quiz/validar/',{
      method:'POST',
      headers:{'Content-Type':'application/json','X-CSRFToken':token},
      body:JSON.stringify({id_questao:questaoId,id_alternativa:selId})
    })
    .then(r=>r.ok?r.json():Promise.reject(new Error('HTTP '+r.status)))
    .then(data=>{
      try{
        // Autoritativo pelo backend
        const corretaBackend = Number(data.id_alternativa_correta);
        const acertouBackend = !!data.acertou;
        const selecionadaBackend = Number(data.id_alternativa_selecionada);
        
        // Limpar TODAS as classes de feedback primeiro
        alternativas.forEach(alt=>{
          alt.classList.remove('alternative-correct','alternative-correct-chosen','alternative-incorrect-chosen');
        });
        
        // Aplicar feedback baseado na resposta do backend
        alternativas.forEach(alt=>{
          const id=Number(alt.getAttribute('data-alternativa-id'));
          
          // Se √© a alternativa CORRETA
          if (id === corretaBackend) {
            // Se foi a alternativa que o usu√°rio clicou (e est√° correta)
            if (id === selecionadaBackend && acertouBackend) {
              alt.classList.add('alternative-correct-chosen'); // Verde com anima√ß√£o
            } else {
              alt.classList.add('alternative-correct'); // Verde simples
            }
          }
          // Se foi a alternativa SELECIONADA e est√° INCORRETA
          else if (id === selecionadaBackend && !acertouBackend) {
            alt.classList.add('alternative-incorrect-chosen'); // Vermelho
          }
        });
        
        const st=card.querySelector('.question-status'); 
        if(st){ 
          st.textContent=acertouBackend?'Certa':'Errada'; 
          st.className='question-status '+(acertouBackend?'certa':'errada'); 
        }
        
        // AGORA desativar cliques nas alternativas ap√≥s processar resposta do backend
        alternativas.forEach(alt=>{ 
          alt.style.pointerEvents='none'; 
          alt.style.cursor='default'; 
        });
        
        // Recarregar estat√≠sticas se a se√ß√£o estiver expandida
        const statsSection = document.getElementById(`stats-section-${questaoId}`);
        if (statsSection && statsSection.style.display !== 'none') {
          // Se√ß√£o est√° expandida, recarregar estat√≠sticas para atualizar hist√≥rico
          setTimeout(() => {
            if (window.fetchAndRenderStatsInline) {
              window.fetchAndRenderStatsInline(questaoId, 'user', 14);
              console.log('üîÑ Estat√≠sticas recarregadas ap√≥s resposta para quest√£o', questaoId);
            }
          }, 300); // Pequeno delay para garantir que o backend processou a resposta
        }
        
        // Toast de feedback removido conforme solicitado
        // if (typeof exibirFeedback==='function'){ 
        //   exibirFeedback(acertouBackend?'Correto! üòÑ':'Incorreto! üò•', acertouBackend); 
        // }
      }catch(e){ 
        console.error('Erro ao processar resposta do backend:', e); 
      }
    })
    .catch((err)=>{ 
      console.error('Erro ao validar resposta:', err); 
      // N√£o quebrar a p√°gina se houver erro na valida√ß√£o
    });
  } catch (err) {
    console.error('Erro geral em responderQuestao:', err);
    // N√£o propagar erro para n√£o quebrar a p√°gina
  }
}

// Expor no escopo global para suportar onclick inline
try { window.responderQuestao = responderQuestao; } catch(_) {}

function atualizarProgresso(){ const total=questoesList.length; const ans=Object.keys(respostas).length; const pct=Math.round((ans/total)*100); const pf=document.querySelector('.progress-fill'); const pt=document.querySelector('.progress-text'); if(pf) pf.style.width=`${pct}%`; if(pt) pt.textContent=`Progresso: ${ans}/${total} (${pct}%)`; }
function inicializarFiltros(){ /* somente contadores j√° tratados em outra tela; nada aqui */ }
function mostrarMensagemVazia(){ const c=document.querySelector('.quiz-vertical-container'); c.innerHTML='<div class="empty-state"><h2>Nenhuma quest√£o encontrada</h2><a class="btn-voltar" href="{% url 'questoes:listar_questoes' assunto.pk %}">Voltar</a></div>'; }

// Favoritos via localStorage (fun√ß√µes locais - toggleFavorito j√° est√° em window)
function getFavKey(){ return 'rq_favoritos'; }
function getFavoritos(){ try{ return new Set(JSON.parse(localStorage.getItem(getFavKey())||'[]')); }catch(e){ return new Set(); } }
function saveFavoritos(set){ localStorage.setItem(getFavKey(), JSON.stringify(Array.from(set))); }
function isFavorito(id){ const favs=getFavoritos(); return favs.has(Number(id)); }
// toggleFavorito j√° foi definido no in√≠cio do script em window.toggleFavorito

// Script imediato para garantir favoritos clic√°veis (executa DEPOIS de toggleFavorito estar definido)
(function(){
  function setupFavoritos(){
    document.querySelectorAll('.fav-btn').forEach(function(btn){
      btn.style.pointerEvents = 'auto';
      btn.style.cursor = 'pointer';
      btn.style.zIndex = '99999';
      btn.style.position = 'relative';
      
      const questaoId = btn.getAttribute('data-questao-id');
      if (questaoId) {
        // Apenas garantir estilos - o onclick inline j√° est√° no HTML
        // N√£o substituir o onclick inline para evitar conflitos
        console.log('üîß Bot√£o favorito configurado:', questaoId);
      }
    });
  }
  
  // Executar imediatamente (toggleFavorito j√° est√° definido acima)
  setupFavoritos();
  
  // Executar tamb√©m quando DOM estiver pronto
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupFavoritos);
  } else {
    setupFavoritos();
  }
  
  // Executar em delays para pegar elementos renderizados depois
  setTimeout(setupFavoritos, 100);
  setTimeout(setupFavoritos, 500);
  
  // Monitorar mudan√ßas no DOM para novos bot√µes
  if (typeof MutationObserver !== 'undefined') {
    const observer = new MutationObserver(function(mutations){
      let needSetup = false;
      mutations.forEach(function(mutation){
        if (mutation.addedNodes.length > 0) {
          mutation.addedNodes.forEach(function(node){
            if (node.nodeType === 1 && (node.classList && node.classList.contains('fav-btn') || (node.querySelector && node.querySelector('.fav-btn')))) {
              needSetup = true;
            }
          });
        }
      });
      if (needSetup) {
        setTimeout(setupFavoritos, 10);
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
})();

// Ap√≥s renderiza√ß√£o, aplicar estado do favorito
function aplicarFavoritosNosCards(){ 
  // Usar window.getFavoritos que foi definido no in√≠cio do script
  if (!window.getFavoritos) {
    console.error('‚ùå window.getFavoritos n√£o est√° dispon√≠vel!');
    return;
  }
  
  const favs = window.getFavoritos();
  const favsArray = Array.from(favs);
  console.log('üîÑ Aplicando favoritos nos cards... Total:', favsArray.length, 'IDs:', favsArray);
  
  const buttons = document.querySelectorAll('.fav-btn');
  console.log('üîç Bot√µes encontrados:', buttons.length);
  
  let aplicados = 0;
  let naoAplicados = 0;
  
  // Aplicar estilos tamb√©m nos bot√µes de estat√≠sticas
  const statsButtons = document.querySelectorAll('.btn-stats');
  statsButtons.forEach((btn)=>{
    btn.style.pointerEvents = 'auto';
    btn.style.cursor = 'pointer';
    btn.style.zIndex = '9999';
    btn.style.position = 'relative';
  });
  
  buttons.forEach((btn, index)=>{ 
    // FOR√áAR pointer-events: auto SEMPRE no bot√£o de favorito (CR√çTICO!)
    btn.style.pointerEvents = 'auto';
    btn.style.cursor = 'pointer';
    btn.style.zIndex = '99999';
    btn.style.position = 'relative';
    
    // Parse ID - tentar m√∫ltiplos atributos
    const idAttr = btn.getAttribute('data-questao-id');
    const idDataset = btn.dataset.questaoId;
    const id = Number(idAttr || idDataset);
    
    if (id && !isNaN(id)) {
      const isFavoritado = favs.has(id);
      console.log(`üîç [${index}] Bot√£o ID: ${id}, √â favorito? ${isFavoritado}`);
      
      // Aplicar classe visual (usar classList.add/remove para mais confiabilidade)
      if (isFavoritado) {
        btn.classList.add('is-fav');
        // FOR√áAR estilo inline como backup
        btn.style.background = '#ff3860';
        btn.style.borderColor = '#ff3860';
        btn.style.color = '#fff';
        aplicados++;
        console.log(`‚úÖ Classe is-fav ADICIONADA e estilo aplicado ao bot√£o ID ${id}`);
      } else {
        btn.classList.remove('is-fav');
        // Remover estilos inline se n√£o for favorito (usar removeProperty tamb√©m)
        btn.style.removeProperty('background');
        btn.style.removeProperty('border-color');
        btn.style.removeProperty('color');
        // Tamb√©m definir como vazio para garantir
        btn.style.background = '';
        btn.style.borderColor = '';
        btn.style.color = '';
        console.log(`‚ùå Classe is-fav REMOVIDA e estilo removido do bot√£o ID ${id}`);
      }
      
      // Marcar no card
      const card = btn.closest('.question-card'); 
      if(card){ 
        if(isFavoritado) {
          card.setAttribute('data-favorito','1');
        } else {
          card.removeAttribute('data-favorito'); 
        }
      }
    } else {
      console.warn(`‚ö†Ô∏è Bot√£o [${index}] sem ID v√°lido. idAttr: "${idAttr}", idDataset: "${idDataset}"`);
      naoAplicados++;
    }
  });
  
  console.log(`üìä Resumo: ${aplicados} favoritos aplicados, ${naoAplicados} sem ID v√°lido`); 
  
  console.log('‚úÖ Favoritos aplicados nos cards!');
}

// Expor no window para poder ser chamada antes do DOMContentLoaded
window.aplicarFavoritosNosCards = aplicarFavoritosNosCards;

// Script adicional que executa DEPOIS que o HTML estiver completamente renderizado
// Este script garante que os favoritos sejam aplicados mesmo se outros scripts interferirem
(function(){
  function forcarAplicacaoFavoritos(){
    if (!window.getFavoritos || !window.aplicarFavoritosNosCards) {
      return;
    }
    
    const favs = window.getFavoritos();
    const favsArray = Array.from(favs);
    
    if (favsArray.length === 0) {
      return;
    }
    
    console.log('üîß FOR√áANDO aplica√ß√£o de favoritos...', favsArray.length, 'favoritos');
    
    const buttons = document.querySelectorAll('.fav-btn');
    console.log('üîç Bot√µes encontrados (for√ßado):', buttons.length);
    
    buttons.forEach((btn)=>{
      const id = Number(btn.getAttribute('data-questao-id') || btn.dataset.questaoId);
      if (id && favs.has(id)) {
        // Aplicar classe
        btn.classList.add('is-fav');
        
        // Aplicar estilos inline FOR√áADOS
        btn.style.setProperty('background', '#ff3860', 'important');
        btn.style.setProperty('border-color', '#ff3860', 'important');
        btn.style.setProperty('color', '#fff', 'important');
        
        // Aplicar no card tamb√©m
        const card = btn.closest('.question-card');
        if (card) {
          card.setAttribute('data-favorito', '1');
        }
        
        console.log('‚úÖ Favorito FOR√áADO ao bot√£o ID', id);
      } else if (id && !favs.has(id)) {
        // Garantir que n√£o-favoritos n√£o tenham a classe
        btn.classList.remove('is-fav');
        // Remover estilos inline quando desfavoritar (usando removeProperty para garantir remo√ß√£o)
        btn.style.removeProperty('background');
        btn.style.removeProperty('border-color');
        btn.style.removeProperty('color');
        // Tamb√©m remover via estilo inline vazio para garantir
        btn.style.background = '';
        btn.style.borderColor = '';
        btn.style.color = '';
        console.log(`‚ùå Favorito REMOVIDO do bot√£o ID ${id}`);
        
        // Remover do card tamb√©m
        const card = btn.closest('.question-card');
        if (card) {
          card.removeAttribute('data-favorito');
        }
      }
    });
  }
  
  // Executar m√∫ltiplas vezes para garantir
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function(){
      setTimeout(forcarAplicacaoFavoritos, 50);
      setTimeout(forcarAplicacaoFavoritos, 200);
      setTimeout(forcarAplicacaoFavoritos, 500);
      setTimeout(forcarAplicacaoFavoritos, 1000);
    });
  } else {
    setTimeout(forcarAplicacaoFavoritos, 50);
    setTimeout(forcarAplicacaoFavoritos, 200);
    setTimeout(forcarAplicacaoFavoritos, 500);
    setTimeout(forcarAplicacaoFavoritos, 1000);
  }
  
  // Tamb√©m executar quando a p√°gina estiver totalmente carregada
  window.addEventListener('load', function(){
    setTimeout(forcarAplicacaoFavoritos, 100);
    setTimeout(forcarAplicacaoFavoritos, 500);
  });
})();

// Aplicar favoritos nos cards renderizados pelo servidor (DEPOIS que a fun√ß√£o estiver definida)
(function(){
  let tentativas = 0;
  const maxTentativas = 20;
  
  function aplicarFavsServidor(){
    tentativas++;
    
    if (!window.aplicarFavoritosNosCards) {
      if (tentativas < maxTentativas) {
        console.warn(`‚ö†Ô∏è window.aplicarFavoritosNosCards ainda n√£o est√° dispon√≠vel (tentativa ${tentativas}/${maxTentativas}), tentando novamente...`);
        setTimeout(aplicarFavsServidor, 50);
      }
      return;
    }
    
    // Verificar se h√° bot√µes no DOM
    const buttons = document.querySelectorAll('.fav-btn');
    if (buttons.length === 0) {
      if (tentativas < maxTentativas) {
        console.warn(`‚ö†Ô∏è Nenhum bot√£o encontrado ainda (tentativa ${tentativas}/${maxTentativas}), tentando novamente...`);
        setTimeout(aplicarFavsServidor, 100);
      }
      return;
    }
    
    console.log('üîÑ Aplicando favoritos em cards do servidor...', buttons.length, 'bot√µes encontrados');
    window.aplicarFavoritosNosCards();
  }
  
  // Esperar um pouco para garantir que o DOM est√° pronto
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function(){
      setTimeout(aplicarFavsServidor, 100);
      setTimeout(aplicarFavsServidor, 300);
      setTimeout(aplicarFavsServidor, 600);
    });
  } else {
    setTimeout(aplicarFavsServidor, 100);
    setTimeout(aplicarFavsServidor, 300);
    setTimeout(aplicarFavsServidor, 600);
  }
  
  // Tamb√©m aplicar quando a janela estiver totalmente carregada
  window.addEventListener('load', function(){
    setTimeout(aplicarFavsServidor, 50);
    setTimeout(aplicarFavsServidor, 200);
  });
})();

// Delega√ß√£o: abrir modal ao clicar no bot√£o de estat√≠sticas
function bindStatsButtons(){
  const qc = document.getElementById('questions-container');
  if (!qc) return;
  // Remove listeners anteriores para evitar duplica√ß√£o
  if (bindStatsButtons.handler) {
    qc.removeEventListener('click', bindStatsButtons.handler, true);
  }
  // Cria novo handler - usar useCapture:true para capturar ANTES de outros listeners
  bindStatsButtons.handler = function(e){
    const btn = e.target.closest('[data-action="ver-estatisticas"]');
    if (!btn) return;
    
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation(); // Impede que outros listeners sejam executados
    
    const id = Number(btn.getAttribute('data-questao-id'));
    if (id && window.toggleStatsSection) {
      console.log('‚úÖ Bot√£o de estat√≠sticas clicado! ID:', id);
      window.toggleStatsSection(id, btn);
    } else {
      console.error('‚ùå toggleStatsSection n√£o est√° dispon√≠vel ou ID inv√°lido:', id);
    }
  };
  qc.addEventListener('click', bindStatsButtons.handler, true); // useCapture:true para capturar ANTES
  console.log('‚úÖ bindStatsButtons: listener adicionado com useCapture:true');
}

// Delega√ß√£o: clicar em alternativas sem inline onclick
function bindAlternativas(){
  const qc = document.getElementById('questions-container');
  if (!qc) {
    console.warn('‚ö†Ô∏è bindAlternativas: questions-container n√£o encontrado');
    return;
  }
  // Remove listeners anteriores para evitar duplica√ß√£o
  if (bindAlternativas.handler) {
    qc.removeEventListener('click', bindAlternativas.handler, false);
  }
  // Cria novo handler
  bindAlternativas.handler = function(e){
    try {
      // PRIMEIRO: Ignora cliques em bot√µes de favorito ou estat√≠sticas (VERIFICA√á√ÉO ANTECIPADA)
      if (e.target.closest('[data-action="toggle-favorito"]') || 
          e.target.closest('[data-action="ver-estatisticas"]') ||
          e.target.closest('.fav-btn') ||
          e.target.closest('.btn-stats') ||
          e.target.classList.contains('fav-btn') ||
          e.target.classList.contains('btn-stats')) {
        return;
      }
      
      const item = e.target.closest('.alternative-item');
      if (!item) return;
      
      // Garantir que a alternativa seja clic√°vel
      item.style.pointerEvents = 'auto';
      item.style.cursor = 'pointer';
      
      const qid = Number(item.getAttribute('data-questao-id'));
      const aid = Number(item.getAttribute('data-alternativa-id'));
      
      if (qid && aid) {
        console.log('üéØ Alternativa clicada via bindAlternativas! Quest√£o:', qid, 'Alternativa:', aid);
        if (typeof window.responderQuestao === 'function') {
          window.responderQuestao(qid, aid, item);
        } else {
          console.error('‚ùå window.responderQuestao n√£o encontrado!');
        }
      } else {
        console.warn('‚ö†Ô∏è bindAlternativas: qid ou aid inv√°lido', { qid, aid });
      }
    } catch (err) {
      console.error('Erro em bindAlternativas handler:', err);
    }
  };
  qc.addEventListener('click', bindAlternativas.handler, false); // false = bubbling phase (DEPOIS do capture)
  console.log('‚úÖ bindAlternativas: listener adicionado');
}

function bindFavoritos(){
  const qc = document.getElementById('questions-container');
  if (!qc) return;
  // Remove listeners anteriores para evitar duplica√ß√£o
  if (bindFavoritos.handler) {
    qc.removeEventListener('click', bindFavoritos.handler, false);
  }
  // Cria novo handler - apenas como fallback se onclick inline n√£o funcionar
  bindFavoritos.handler = function(e){
    // PRIMEIRO: Ignorar cliques em bot√µes de estat√≠sticas
    if (e.target.closest('[data-action="ver-estatisticas"]') || e.target.closest('.btn-stats')) {
      return; // Deixa bindStatsButtons tratar
    }
    
    // N√ÉO interceptar se j√° foi tratado pelo onclick inline
    // Apenas servir como fallback
    let btn = e.target.closest('.fav-btn');
    if (!btn && (e.target.textContent === '‚ù§' || e.target.textContent.includes('‚ù§'))) {
      btn = e.target.closest('.fav-btn') || e.target.parentElement;
      while(btn && !btn.classList.contains('fav-btn') && btn !== document.body) {
        btn = btn.parentElement;
      }
    }
    
    if (!btn || !btn.classList.contains('fav-btn')) return;
    
    // Verificar se j√° foi tratado pelo onclick inline
    if (e.defaultPrevented) return;
    
    console.log('üîç bindFavoritos: fallback ativado para:', btn);
    
    const id = Number(btn.getAttribute('data-questao-id'));
    if (id && window.toggleFavorito) {
      e.preventDefault();
      e.stopPropagation();
      console.log('‚úÖ Favorito clicado (bindFavoritos fallback):', id);
      window.toggleFavorito(id, btn);
    }
  };
  qc.addEventListener('click', bindFavoritos.handler, false); // false = bubbling (DEPOIS do onclick inline)
  console.log('‚úÖ bindFavoritos: listener de fallback adicionado');
}

// Ajusta chamadas existentes - garantir que favoritos sejam aplicados ap√≥s renderizar
const _renderizarTodas = renderizarTodasQuestoes; 
renderizarTodasQuestoes = function(){ 
  try {
    _renderizarTodas(); 
  } catch (err) {
    console.error('Erro ao renderizar quest√µes:', err);
    // Continuar mesmo com erro para n√£o quebrar a p√°gina
  }
  setTimeout(()=>{ 
    try {
      aplicarFavoritosNosCards(); // Aplicar favoritos imediatamente
    } catch (err) {
      console.error('Erro ao aplicar favoritos:', err);
    }
    try {
      bindStatsButtons(); 
    } catch (err) {
      console.error('Erro ao vincular bot√µes de estat√≠sticas:', err);
    }
    try {
      bindAlternativas(); 
    } catch (err) {
      console.error('Erro ao vincular alternativas:', err);
    }
    try {
      bindFavoritos(); 
    } catch (err) {
      console.error('Erro ao vincular favoritos:', err);
    }
  }, 0); 
  // Aplicar favoritos novamente ap√≥s pequeno delay (com tratamento de erro)
  setTimeout(()=>{ 
    try { aplicarFavoritosNosCards(); } 
    catch (err) { console.error('Erro ao aplicar favoritos (delay 50ms):', err); }
  }, 50);
  setTimeout(()=>{ 
    try { aplicarFavoritosNosCards(); } 
    catch (err) { console.error('Erro ao aplicar favoritos (delay 200ms):', err); }
  }, 200);
};

// Monitor global de cliques para debug
(function(){
  document.addEventListener('click', function(e){
    if (e.target.closest('.btn-stats') || e.target.closest('[data-action="ver-estatisticas"]')) {
      console.log('üîç CLIQUE GLOBAL detectado no bot√£o de estat√≠sticas!', e.target);
      const btn = e.target.closest('.btn-stats') || e.target.closest('[data-action="ver-estatisticas"]');
      if (btn) {
        const id = btn.getAttribute('data-questao-id');
        console.log('‚úÖ Bot√£o encontrado, ID:', id);
        console.log('‚úÖ window.toggleStatsSection dispon√≠vel?', typeof window.toggleStatsSection);
        console.log('‚úÖ Estilos do bot√£o:', {
          pointerEvents: window.getComputedStyle(btn).pointerEvents,
          cursor: window.getComputedStyle(btn).cursor,
          zIndex: window.getComputedStyle(btn).zIndex,
          position: window.getComputedStyle(btn).position
        });
      }
    }
  }, true);
})();

// Fun√ß√£o para renderizar estat√≠sticas inline (dentro do card da quest√£o)
window.fetchAndRenderStatsInline = async function(idQuestao, scope, days) {
  try {
    console.log('üöÄ fetchAndRenderStatsInline chamado para quest√£o', idQuestao, 'scope:', scope, 'days:', days);
    
    const url = `/questoes/${idQuestao}/estatisticas/?format=json&scope=${encodeURIComponent(scope)}&days=${encodeURIComponent(days)}`;
    console.log('üì° Fazendo requisi√ß√£o para:', url);
    
    const res = await fetch(url, { headers: { 'X-Requested-With':'XMLHttpRequest' }, credentials: 'same-origin' });
    
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }
    
    const json = await res.json();
    console.log('üì¶ Resposta recebida:', json);
    
    if (!json.success && json.data === undefined) {
      throw new Error(json.message || 'Erro ao obter estat√≠sticas do servidor');
    }
    
    const d = (json.data !== undefined) ? json.data : json;
    console.log('‚úÖ Dados processados:', {
      totals: d.totals,
      historicoLength: (d.historico || []).length,
      byAlternative: d.by_alternative
    });
    
    // Renderizar gr√°ficos inline
    if (typeof window.renderChartsInline === 'function') {
      try {
        console.log('üìä Renderizando gr√°ficos para quest√£o', idQuestao);
        window.renderChartsInline(idQuestao, d);
      } catch (chartErr) {
        console.error('‚ùå Erro ao renderizar gr√°ficos inline:', chartErr);
      }
    } else {
      console.error('‚ùå renderChartsInline n√£o est√° dispon√≠vel!');
    }
    
    // Renderizar hist√≥rico inline
    if (typeof window.renderHistoricoInline === 'function') {
      try {
        const historico = d.historico || [];
        console.log('üìù Renderizando hist√≥rico para quest√£o', idQuestao, 'total de itens recebidos:', historico.length);
        console.log('üìù Dados do hist√≥rico completo:', JSON.stringify(historico, null, 2));
        window.renderHistoricoInline(idQuestao, historico);
      } catch (histErr) {
        console.error('‚ùå Erro ao renderizar hist√≥rico inline:', histErr);
        const container = document.getElementById(`historicoRespostas-${idQuestao}`);
        if (container) {
          container.innerHTML = '<div class="history-empty">Erro ao carregar hist√≥rico.</div>';
        }
      }
    } else {
      console.error('‚ùå renderHistoricoInline n√£o est√° dispon√≠vel!');
    }
    
    console.log('‚úÖ Estat√≠sticas carregadas e renderizadas com sucesso para quest√£o', idQuestao);
  } catch (err) {
    console.error('‚ùå Erro completo ao buscar estat√≠sticas inline:', err);
    const container = document.getElementById(`historicoRespostas-${idQuestao}`);
    if (container) {
      container.innerHTML = '<div class="history-empty">Erro ao carregar estat√≠sticas: ' + (err.message || 'Desconhecido') + '</div>';
    }
  }
};

// Manter fun√ß√£o antiga para compatibilidade (caso ainda seja chamada)
window.fetchAndRenderStats = async function(idQuestao, scope, days) {
  try {
    const url = `/questoes/${idQuestao}/estatisticas/?format=json&scope=${encodeURIComponent(scope)}&days=${encodeURIComponent(days)}`;
    const res = await fetch(url, { headers: { 'X-Requested-With':'XMLHttpRequest' }, credentials: 'same-origin' });
    
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }
    
    const json = await res.json();
    
    if (!json.success && json.data === undefined) {
      throw new Error(json.message || 'Erro ao obter estat√≠sticas do servidor');
    }
    
    const d = (json.data !== undefined) ? json.data : json; // compat fallback
    
    // Atualizar elementos do modal com seguran√ßa
    try {
      const assuntoEl = document.getElementById('statsAssunto');
      const scopeEl = document.getElementById('statsScope');
      const periodEl = document.getElementById('statsPeriod');
      
      if (assuntoEl) assuntoEl.textContent = d.assunto || '';
      if (scopeEl) scopeEl.textContent = d.scope === 'user' ? 'Minhas' : 'Geral';
      if (periodEl) periodEl.textContent = String(d.period_days || days);
      
      // Renderizar gr√°ficos com tratamento de erro
      if (typeof window.renderCharts === 'function') {
        try {
          window.renderCharts(d);
        } catch (chartErr) {
          console.error('Erro ao renderizar gr√°ficos:', chartErr);
        }
      }
      
      // Renderizar hist√≥rico com tratamento de erro
      if (typeof window.renderHistorico === 'function') {
        try {
          window.renderHistorico(d.historico || []);
        } catch (histErr) {
          console.error('Erro ao renderizar hist√≥rico:', histErr);
          const container = document.getElementById('historicoRespostas');
          if (container) {
            container.innerHTML = '<div class="history-empty">Erro ao carregar hist√≥rico.</div>';
          }
        }
      }
    } catch (renderErr) {
      console.error('Erro ao atualizar elementos do modal:', renderErr);
      throw renderErr;
    }
  } catch (err) {
    console.error('Erro completo ao buscar estat√≠sticas:', err);
    // N√£o bloquear a p√°gina se houver erro - apenas mostrar mensagem
    alert('N√£o foi poss√≠vel carregar as estat√≠sticas desta quest√£o. Erro: ' + (err.message || 'Desconhecido'));
  }
};

// Fun√ß√£o para renderizar gr√°ficos inline (com ID √∫nico por quest√£o)
window.renderChartsInline = function(idQuestao, d){
  try {
    const acc = d.totals || { total_attempts:0, correct_attempts:0, wrong_attempts:0 };
    const labels = ['A','B','C','D','E'];
    const byAlt = d.by_alternative || {}; 
    const values = labels.map(l=> byAlt[l]||0);
    
    console.log('üìä Dados recebidos para gr√°ficos:', {
      totals: acc,
      byAlternative: byAlt,
      values: values,
      labels: labels
    });

    // Gr√°fico de rosca: Percentual de Rendimento (Acertos vs Erros)
    const accCtx = document.getElementById(`chartAccuracy-${idQuestao}`);
    if (!accCtx) {
      console.warn('Elemento chartAccuracy n√£o encontrado para quest√£o', idQuestao);
      return;
    }
    
    // Destruir gr√°fico anterior se existir
    const chartKeyAccuracy = `chartAccuracy_${idQuestao}`;
    if (window[chartKeyAccuracy]) {
      try {
        window[chartKeyAccuracy].destroy();
      } catch (destroyErr) {
        console.warn('Erro ao destruir gr√°fico anterior:', destroyErr);
      }
    }
    
    try {
      window[chartKeyAccuracy] = new Chart(accCtx.getContext('2d'), { 
        type:'doughnut', 
        data:{ 
          labels:['Acertos','Erros'], 
          datasets:[{ 
            data:[acc.correct_attempts||0, acc.wrong_attempts||0], 
            backgroundColor:['#10B981','#EF4444'], 
            borderWidth:0 
          }] 
        }, 
        options:{ 
          plugins:{ 
            legend:{ 
              position:'bottom',
              labels: {
                padding: 15,
                font: { size: 12, weight: '600' }
              }
            }
          }, 
          cutout:'60%',
          maintainAspectRatio: false
        } 
      });
    } catch (chartErr) {
      console.error('Erro ao criar gr√°fico de rosca inline:', chartErr);
    }

    // Gr√°fico de barras: Alternativas mais respondidas
    const altCtx = document.getElementById(`chartAlternatives-${idQuestao}`);
    if (!altCtx) {
      console.warn('Elemento chartAlternatives n√£o encontrado para quest√£o', idQuestao);
      return;
    }
    
    // Destruir gr√°fico anterior se existir
    const chartKeyAlternatives = `chartAlternatives_${idQuestao}`;
    if (window[chartKeyAlternatives]) {
      try {
        window[chartKeyAlternatives].destroy();
      } catch (destroyErr) {
        console.warn('Erro ao destruir gr√°fico de barras anterior:', destroyErr);
      }
    }
    
    // Cores para cada alternativa
    const altColors = ['#F97316', '#3B82F6', '#8B5CF6', '#EF4444', '#10B981'];
    
    try {
      window[chartKeyAlternatives] = new Chart(altCtx.getContext('2d'), {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Respostas por alternativa',
            data: values,
            backgroundColor: labels.map((_, i) => altColors[i] || '#64748b')
          }]
        },
        options: {
          scales: {
            y: {
              beginAtZero: true,
              ticks: { precision: 0, stepSize: 1 }
            }
          },
          plugins: { 
            legend: { display: false } 
          },
          maintainAspectRatio: false
        }
      });
    } catch (chartErr) {
      console.error('Erro ao criar gr√°fico de barras inline:', chartErr);
    }
  } catch (err) {
    console.error('Erro geral em renderChartsInline:', err);
  }
};

// Manter fun√ß√£o antiga para compatibilidade
window.renderCharts = function(d){
  try {
    const acc = d.totals || { total_attempts:0, correct_attempts:0, wrong_attempts:0 };
    const labels = ['A','B','C','D','E'];
    const byAlt = d.by_alternative || {}; 
    const values = labels.map(l=> byAlt[l]||0);

    // Gr√°fico de rosca: Percentual de Rendimento (Acertos vs Erros)
    const accCtx = document.getElementById('chartAccuracy');
    if (!accCtx) {
      console.warn('Elemento chartAccuracy n√£o encontrado');
      return;
    }
    
    if (window.chartAccuracy) {
      try {
        window.chartAccuracy.destroy();
      } catch (destroyErr) {
        console.warn('Erro ao destruir gr√°fico anterior:', destroyErr);
      }
    }
    
    try {
      window.chartAccuracy = new Chart(accCtx.getContext('2d'), { 
        type:'doughnut', 
        data:{ 
          labels:['Acertos','Erros'], 
          datasets:[{ 
            data:[acc.correct_attempts||0, acc.wrong_attempts||0], 
            backgroundColor:['#10B981','#EF4444'], 
            borderWidth:0 
          }] 
        }, 
        options:{ 
          plugins:{ 
            legend:{ 
              position:'bottom',
              labels: {
                padding: 15,
                font: { size: 12, weight: '600' }
              }
            }
          }, 
          cutout:'60%',
          maintainAspectRatio: false
        } 
      });
    } catch (chartErr) {
      console.error('Erro ao criar gr√°fico de rosca:', chartErr);
    }

    // Gr√°fico de barras: Alternativas mais respondidas
    const altCtx = document.getElementById('chartAlternatives');
    if (!altCtx) {
      console.warn('Elemento chartAlternatives n√£o encontrado');
      return;
    }
    
    if (window.chartAlternatives) {
      try {
        window.chartAlternatives.destroy();
      } catch (destroyErr) {
        console.warn('Erro ao destruir gr√°fico de barras anterior:', destroyErr);
      }
    }
    
    // Cores para cada alternativa (baseado na imagem: A=laranja, B=azul)
    const altColors = ['#F97316', '#3B82F6', '#8B5CF6', '#EF4444', '#10B981'];
    
    try {
      window.chartAlternatives = new Chart(altCtx.getContext('2d'), {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Respostas por alternativa',
            data: values,
            backgroundColor: labels.map((_, i) => altColors[i] || '#64748b')
          }]
        },
        options: {
          scales: {
            y: {
              beginAtZero: true,
              ticks: { precision: 0, stepSize: 1 }
            }
          },
          plugins: { 
            legend: { display: false } 
          },
          maintainAspectRatio: false
        }
      });
    } catch (chartErr) {
      console.error('Erro ao criar gr√°fico de barras:', chartErr);
    }
  } catch (err) {
    console.error('Erro geral em renderCharts:', err);
    // N√£o propagar erro para n√£o quebrar a p√°gina
  }
};

// Fun√ß√£o para renderizar hist√≥rico de respostas inline (com ID √∫nico por quest√£o)
window.renderHistoricoInline = function(idQuestao, historico){
  console.log('üìù renderHistoricoInline chamado para quest√£o', idQuestao, 'com', (historico || []).length, 'itens');
  
  const container = document.getElementById(`historicoRespostas-${idQuestao}`);
  if (!container) {
    console.error('‚ùå Container de hist√≥rico n√£o encontrado para quest√£o', idQuestao);
    return;
  }
  
  if (!historico || historico.length === 0) {
    console.log('‚ö†Ô∏è Hist√≥rico vazio para quest√£o', idQuestao);
    container.innerHTML = '<div class="history-empty">Nenhuma resposta registrada ainda.</div>';
    return;
  }
  
  console.log('‚úÖ Processando', historico.length, 'itens do hist√≥rico');
  
  // Ordenar por data (mais recente primeiro) - criar c√≥pia para n√£o alterar original
  const historicoOrdenado = [...historico].sort((a, b) => {
    if (a.data_iso && b.data_iso) {
      return new Date(b.data_iso).getTime() - new Date(a.data_iso).getTime();
    }
    return 0;
  });
  
  console.log('‚úÖ Hist√≥rico ordenado. Itens:', historicoOrdenado.map(h => ({ data: h.data, alternativa: h.alternativa, acertou: h.acertou })));
  
  container.innerHTML = historicoOrdenado.map(item => {
    const resultClass = item.acertou ? 'correct' : 'incorrect';
    const resultText = item.acertou ? 'Voc√™ acertou!' : 'Voc√™ errou!';
    const resultIcon = item.acertou ? '‚úì' : '‚úó';
    
    return '<div class="history-item">' +
      '<span class="history-item-text">Em ' + item.data + ', voc√™ respondeu a op√ß√£o ' + item.alternativa + '.</span>' +
      '<div class="history-item-result ' + resultClass + '">' +
      '<span class="history-item-result-icon">' + resultIcon + '</span>' +
      '<span>' + resultText + '</span>' +
      '</div>' +
      '</div>';
  }).join('');
  
  console.log('‚úÖ Hist√≥rico renderizado com sucesso! Total de itens exibidos:', historicoOrdenado.length);
};

// Manter fun√ß√£o antiga para compatibilidade
window.renderHistorico = function(historico){
  const container = document.getElementById('historicoRespostas');
  if (!container) return;
  
  if (!historico || historico.length === 0) {
    container.innerHTML = '<div class="history-empty">Nenhuma resposta registrada ainda.</div>';
    return;
  }
  
  container.innerHTML = historico.map(item => {
    const resultClass = item.acertou ? 'correct' : 'incorrect';
    const resultText = item.acertou ? 'Voc√™ acertou!' : 'Voc√™ errou!';
    const resultIcon = item.acertou ? '‚úì' : '‚úó';
    
    return '<div class="history-item">' +
      '<span class="history-item-text">Em ' + item.data + ', voc√™ respondeu a op√ß√£o ' + item.alternativa + '.</span>' +
      '<div class="history-item-result ' + resultClass + '">' +
      '<span class="history-item-result-icon">' + resultIcon + '</span>' +
      '<span>' + resultText + '</span>' +
      '</div>' +
      '</div>';
  }).join('');
};

</script>

<!-- Modal removido - agora usamos se√ß√µes inline dentro de cada card -->

<style>
.stats-charts-grid{ 
  display:grid; 
  grid-template-columns:1fr 1fr; 
  gap:24px; 
  margin-bottom:30px;
}
.chart-box-left, .chart-box-right{ 
  background:#f8fafc; 
  border:1px solid #e5e7eb; 
  border-radius:12px; 
  padding:20px; 
}
.chart-title{ 
  font-size:1.1rem; 
  font-weight:700; 
  color:#0f172a; 
  margin-bottom:16px; 
  text-align:center;
}
.chart-container{ 
  position:relative; 
  height:200px; 
  display:flex; 
  align-items:center; 
  justify-content:center;
}
.history-section{ 
  margin-top:24px; 
  padding-top:24px; 
  border-top:2px solid #e5e7eb;
}
.history-title{ 
  font-size:1.1rem; 
  font-weight:700; 
  color:#0f172a; 
  margin-bottom:16px; 
}
.history-list{ 
  display:flex; 
  flex-direction:column; 
  gap:12px;
}
.history-item{ 
  background:#f8fafc; 
  border:1px solid #e5e7eb; 
  border-radius:10px; 
  padding:16px; 
  display:flex; 
  align-items:center; 
  justify-content:space-between;
}
.history-item-text{ 
  flex:1; 
  color:#0f172a; 
  font-size:.95rem;
}
.history-item-result{ 
  display:flex; 
  align-items:center; 
  gap:8px; 
  font-weight:700;
}
.history-item-result.correct{ color:#10B981; }
.history-item-result.incorrect{ color:#EF4444; }
.history-item-result-icon{ 
  width:24px; 
  height:24px; 
  border-radius:50%; 
  display:flex; 
  align-items:center; 
  justify-content:center; 
  font-weight:900; 
  font-size:14px;
}
.history-item-result.correct .history-item-result-icon{ 
  background:#10B981; 
  color:#fff; 
}
.history-item-result.incorrect .history-item-result-icon{ 
  background:#EF4444; 
  color:#fff; 
}
.history-empty{ 
  text-align:center; 
  padding:40px 20px; 
  color:#64748b; 
  font-style:italic;
}
.stats-scope{ 
  margin-top:24px; 
  display:flex; 
  gap:8px; 
  justify-content:flex-end; 
  padding-top:20px;
  border-top:1px solid #e5e7eb;
}
.scope-btn{ 
  border:1px solid #cbd5e1; 
  background:#fff; 
  padding:10px 16px; 
  border-radius:8px; 
  cursor:pointer; 
  font-weight:600;
  transition:all .2s;
}
.scope-btn:hover{ background:#f8fafc; }
.scope-btn.active{ 
  border-color:#0072FF; 
  background:#0072FF;
  color:#fff; 
  font-weight:700; 
}
@media (max-width:768px){
  .stats-charts-grid{ grid-template-columns:1fr; }
  .stats-section-inline{ padding:15px; }
}
</style>
{% endblock %}

